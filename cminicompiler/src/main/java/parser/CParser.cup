/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;
import lexer.CLexer;
import handler.Analyzer;
import model.Token;
import errors.SyntaxError;

parser code {:

    CLexer s;
    Analyzer a;

    public void bind(CLexer lexer, Analyzer analyzer) {
        this.s = lexer;
        this.a = analyzer;
    }

    public void generateSyntaxError(String message, String expected, Object o) {

        if (o != null)
        {
          Token findedToken = (Token) o;
          this.a.addSyntaxError(new SyntaxError(message, findedToken));
        }
        else
        {
          this.a.addSyntaxError(new SyntaxError(message + " at line:" + s.getCurrentLine(), null));
        }
    }

    public void syntax_error(Symbol cur_token) 
    {
	    System.err.println("Syntax error at line: " + (cur_token.right+1) + " at column: " + (cur_token.left+1) + " on: " + cur_token.value);
    }

    public void unrecovered_syntax_error(Symbol cur_token) 
    {
    	System.err.println("Fatal error at line: " + (cur_token.right+1) + " at column: " + (cur_token.left+1) + " on: " + cur_token.value);
    }
:}

init with {:  :};
scan with {: return this.s.next_token(); :};

/* Terminals (tokens returned by the scanner). */
  terminal IDENT;
  terminal KW_AUTO,KW_BREAK,KW_CASE,KW_CHAR,KW_CONST;
  terminal KW_CONTINUE,KW_DEFAULT,KW_DO,KW_DOUBLE,KW_ELSE;
  terminal KW_ENUM,KW_EXTERN,KW_FLOAT,KW_FOR,KW_GOTO;
  terminal KW_IF,KW_INT,KW_LONG,KW_REGISTER,KW_RETURN;
  terminal KW_SHORT,KW_SIGNED,KW_SIZEOF,KW_STATIC,KW_STRUCT;
  terminal KW_SWITCH,KW_TYPEDEF,KW_UNION,KW_UNSIGNED,KW_VOID;
  terminal KW_VOLATILE,KW_WHILE,OP_DIV,OP_PLUS,OP_MINUS;
  terminal OP_MULT,OP_MOD,OP_COMMA,OP_GTE,OP_LTE;
  terminal OP_LT,OP_GT,OP_NOTEQUALCOMP,OP_ORCOMP,OP_ANDCOMP;
  terminal OP_EQUALCOMP,OP_AND,OP_XOR,OP_OR,OP_NOT;
  terminal OP_NEGATION,OP_PLUSASSIGN,OP_MINUSASSIGN,OP_MULTASSIGN,OP_DIVASSIGN;
  terminal OP_MINUSMINUSASSIGN,OP_PLUSPLUSASSIGN,OP_MODASSIGN,OP_ANDASSIGN,OP_NOTASSIGN;
  terminal OP_ORASSIGN,OP_SHIFTLEFTASSIGN,OP_SHIFTRIGHTASSIGN,OP_TERNARYOPERATORQUESTIONMARK,OP_TERNARYOPERATIONDOUBLEDOT;
  terminal OP_ASIG,OP_SHIFTOPRIGHT,OP_SHIFTOPLEFT,OP_PROPOPERATOR;
  terminal OP_WRAPPERPARENTHESISLEFT,OP_WRAPPERPARENTHESISRIGHT,OP_WRAPPERSQUAREPARENTHESISLEFT,OP_WRAPPERSQUAREPARENTHESISRIGHT,OP_WRAPPERKEYPARENTHESISLEFT,OP_WRAPPERKEYPARENTHESISRIGHT;
  terminal OP_INSTRUCTIONENDOPERATOR,OP_POINTEROPERATOR,OP_POINTEROPERATORASTERISC,LIT_HEXVALUE,LIT_DECIMALVALUE,LIT_FLOATVALUE,LIT_CHARVALUE,LIT_OCTALVALUE,LIT_STRINGDEF,LIT_EXPONENTIALDEF;
  terminal NEWLINE;

/* Non Terminals (generated using the terminals tokens) */
  //Non-terminals function
  non terminal  function_declaration_0,
                function_declaration_1,
                function_declaration,
                unknown_function_declaration_error,
                keyword_types,
                parameters,
                parameter,
                parameters_definition,
                parameter_definition,
                program_definition
                ;

  non terminal  gramatic_body,
                gramatic_body_0;
  //Non-terminal expressions
  non terminal  instruction,
                expression,
                expression_any_type,
                expression_numeric,
                expression_atomic,
                expression_unary_operator,
                expression_binary_operators
                ;

  non terminal expression_atomic_literal_int,
              expression_atomic_literal_nonint
              ;

  non terminal expression_atomic_call_functions_anytype;
  //Non-terminal Variables
  non terminal global, constant, variable, variable_definition;
  //Non-terminal Estrucutura Control
  non terminal control_structure, control_if, control_if_else, control_else; 

  //Non-terminal switch
  non terminal control_switch, control_switch_case;

  //Non-terminal ciclo while
  non terminal control_while, control_while_body;

  //Non terminal ciclo for
  non terminal control_for, control_for_instruction, control_for_instruction1, control_for_body;

  //Program Start non termi
  non terminal start_program;

  //Error non terminal productions
  non terminal 
    error_if, 
    error_while, 
    error_for, 
    error_function_declaration, 
    error_function,
    error_variable_definition,
    error_switch,
    error_constant,
    error_parameter,
    error_gramatic,
    error_program_definition;

//Definicion de precedencias
//precedence gramatic body
  precedence left     IDENT;
  precedence left     OP_WRAPPERKEYPARENTHESISLEFT, OP_WRAPPERKEYPARENTHESISRIGHT;
  precedence left     OP_WRAPPERPARENTHESISLEFT, OP_WRAPPERPARENTHESISRIGHT;
  precedence nonassoc     LIT_DECIMALVALUE, LIT_FLOATVALUE, LIT_HEXVALUE, LIT_OCTALVALUE, LIT_EXPONENTIALDEF, LIT_CHARVALUE, LIT_STRINGDEF;     
  precedence right  OP_INSTRUCTIONENDOPERATOR;
  //predence If-ELSE
  precedence left KW_ELSE, KW_RETURN;
  precedence right KW_IF;
  precedence nonassoc KW_CONST;

  //precedence Switch
  precedence left KW_CASE,KW_SWITCH;
  precedence right KW_BREAK;

  //precedence While
  precedence left KW_WHILE, KW_FOR;
  precedence nonassoc KW_CONTINUE, KW_BREAK;

  //precedende variables
  precedence nonassoc KW_INT 
                    , KW_CHAR 
                    , KW_LONG 
                    , KW_SHORT 
                    , KW_VOID
                    , KW_FLOAT
                    , KW_DOUBLE
                    ;
  //precedence operators expression
  precedence left     OP_PLUS, OP_MINUS;
  precedence left     OP_MULT, OP_DIV, OP_MOD;
  precedence left     OP_TERNARYOPERATORQUESTIONMARK, OP_TERNARYOPERATIONDOUBLEDOT;

  precedence nonassoc 
      //RELATIONAL OPERATORS 
        OP_LT
      , OP_LTE
      , OP_GT 
      , OP_GTE 
      , OP_EQUALCOMP
      , OP_NOTEQUALCOMP
      //LOGICAL OPERATORS
      , OP_ANDCOMP
      , OP_ORCOMP
      , OP_NEGATION
      //BITWISE OPERATORS  
      , OP_AND 
      , OP_OR 
      , OP_SHIFTOPLEFT
      , OP_SHIFTOPRIGHT
      , OP_NOT
      , OP_XOR
      //ASSIGMENT OPERATORS
      , OP_ASIG
      , OP_PLUSASSIGN
      , OP_MINUSASSIGN
      , OP_MULTASSIGN
      , OP_DIVASSIGN
      , OP_MODASSIGN
      , OP_SHIFTLEFTASSIGN
      , OP_SHIFTRIGHTASSIGN
      , OP_NOTASSIGN
      , OP_ORASSIGN
      , OP_ANDASSIGN
        //UNARY OPERATORS
        //--
      , OP_MINUSMINUSASSIGN 
        //++
      , OP_PLUSPLUSASSIGN
      ;

start with start_program;

//Referencias
//https://stackoverflow.com/questions/44091680/java-cup-runtime-symbol-eof-has-not-been-declared
//https://www.cs.auckland.ac.nz/courses/compsci330s1c/lectures/330ChaptersPDF/Chapt4.pdf

start_program ::= 
    program_definition
    ;

program_definition ::= 
      function_declaration:fd program_definition:pd 
    | global:g program_definition:pd      
    | constant:c program_definition:pd
    | error_program_definition:e_p_d program_definition:pd
      {: System.out.println("$Error program definition, line 213. ");
      :}
    |
    ;

error_program_definition ::=
   keyword_types:kw_type OP_INSTRUCTIONENDOPERATOR
    {:
      parser.generateSyntaxError("Must give a name for a global variable", "Global variable", kw_type);
    :}
  | instruction:instr OP_INSTRUCTIONENDOPERATOR
    {:
      parser.generateSyntaxError("Instruction out of place", "Global variable", instr);
    :}
  | keyword_types error:e OP_INSTRUCTIONENDOPERATOR
      {:
        parser.generateSyntaxError("Multiple variable definition require comma as separator", ",", e);
      :}
  | error_constant
  | error:e OP_INSTRUCTIONENDOPERATOR
    {:
      parser.generateSyntaxError("Syntax error UNKNOWN TYPE", "UNKNOWN", e);
    :}
  | error:e OP_WRAPPERKEYPARENTHESISRIGHT
  {:
    parser.generateSyntaxError("Syntax error UNKNOWN TYPE", "UNKNOWN", e);
  :} 
  | error:e OP_WRAPPERKEYPARENTHESISLEFT
  {:
    parser.generateSyntaxError("Syntax error UNKNOWN TYPE", "UNKNOWN", e);
  :} 
  ;
/*
Funciones -> Tipo Identifier ( Parametros ) { CuerpoGramatica} | Tipo Identifier ( Parametros )*/
  function_declaration ::= 
    keyword_types:kt IDENT OP_WRAPPERPARENTHESISLEFT  function_declaration_0 function_declaration_1
    //| error_function_declaration
   
    ;

  function_declaration_0 ::=
      parameters_definition OP_WRAPPERPARENTHESISRIGHT 
    | OP_WRAPPERPARENTHESISRIGHT
    ;

  function_declaration_1 ::=
      OP_WRAPPERKEYPARENTHESISLEFT gramatic_body OP_WRAPPERKEYPARENTHESISRIGHT
      ;

  unknown_function_declaration_error ::=
      error:e OP_INSTRUCTIONENDOPERATOR
    {:
      parser.generateSyntaxError("Syntax error function declaration UNKNOWN TYPE 1", "UNKNOWN", e);
    :}
    | error:e OP_WRAPPERKEYPARENTHESISRIGHT
    {:
      parser.generateSyntaxError("Syntax error function declaration UNKNOWN TYPE 2", "UNKNOWN", e);
    :} 
    | error:e OP_WRAPPERKEYPARENTHESISLEFT
    {:
      parser.generateSyntaxError("Syntax error function declaration UNKNOWN TYPE 3", "UNKNOWN", e);
    :} 
    ;

  error_function_declaration ::= 
      error:e IDENT:fn OP_WRAPPERPARENTHESISLEFT function_declaration_0 function_declaration_1 {:
        parser.generateSyntaxError("Type function missing", "int, float,...", e);
      :}
    |
       keyword_types:kt error:e OP_WRAPPERPARENTHESISLEFT  function_declaration_0 function_declaration_1 {:
        parser.generateSyntaxError("Function identifier missing", "getSalary", e);
      :}
    |
       keyword_types:kt IDENT error:e  function_declaration_0 function_declaration_1{:
        parser.generateSyntaxError("Left parenthesis missing", "(", e);
      :}
    |
       keyword_types:kt IDENT OP_WRAPPERPARENTHESISLEFT  error:e OP_WRAPPERPARENTHESISRIGHT function_declaration_1{:
        parser.generateSyntaxError("Error parameters declaration", "int a, float b", e);
      :}
    ;
/*EstructuraControl	->  Control-If | Control-Switch | Control-While | Control-For*/
  control_structure::=
        control_if
      | control_switch
      | control_while
      | control_for
    ;

//Estructura de control if
  control_if ::=
        control_if_else
      | error_if
      ;

  control_if_else::=  
      KW_IF OP_WRAPPERPARENTHESISLEFT expression OP_WRAPPERPARENTHESISRIGHT gramatic_body control_else
    ;

  control_else::=
        KW_ELSE gramatic_body
      | KW_ELSE instruction
      | instruction
      | gramatic_body
      ;

  error_if ::=
      KW_IF:i error:e expression OP_WRAPPERPARENTHESISRIGHT gramatic_body control_else {: 
        parser.generateSyntaxError("IF: Left parenthesis missing", "(", e);
      :}
    | 
      KW_IF:i OP_WRAPPERPARENTHESISLEFT error:e OP_WRAPPERPARENTHESISRIGHT gramatic_body control_else {: 
        parser.generateSyntaxError("IF: Expression missing in conditional structure", "expression", e);
      :}
    |
      KW_IF:i OP_WRAPPERPARENTHESISLEFT expression error:e gramatic_body control_else {:    
        parser.generateSyntaxError("IF: Right parenthesis missing", ")", e);
      :}
    |
      KW_IF:i error:e  gramatic_body control_else {:    
        parser.generateSyntaxError("IF: Some code between if and conditional expression", "If", e);
      :}
    | 
      KW_IF OP_WRAPPERPARENTHESISLEFT expression OP_WRAPPERPARENTHESISRIGHT error:e gramatic_body control_else {:    
        parser.generateSyntaxError("IF: Syntax error, illegal code inside of the if", "If", e);
      :}
    ;

//estructura de control switch
  control_switch::=
        KW_SWITCH OP_WRAPPERPARENTHESISLEFT expression_numeric OP_WRAPPERPARENTHESISRIGHT control_switch_case
      //| error_switch
      ;


  control_switch_case::=
      OP_WRAPPERKEYPARENTHESISLEFT control_switch_case OP_WRAPPERKEYPARENTHESISRIGHT  control_switch_case
    | KW_CASE     expression_numeric  OP_TERNARYOPERATIONDOUBLEDOT                    control_switch_case
    | KW_DEFAULT  expression_numeric  OP_TERNARYOPERATIONDOUBLEDOT                    control_switch_case
    | KW_BREAK OP_INSTRUCTIONENDOPERATOR                                              control_switch_case
    | gramatic_body                                                              
    ;

  error_switch ::=
      KW_SWITCH:s error:e OP_WRAPPERKEYPARENTHESISRIGHT {:
        parser.generateSyntaxError("Left parenthesis missing", "(", s);
      :}
    | KW_SWITCH:s OP_WRAPPERPARENTHESISLEFT error:e OP_WRAPPERKEYPARENTHESISRIGHT {:
        parser.generateSyntaxError("Numeric expresion expected", "expression", s);
      :}
    | KW_SWITCH:s OP_WRAPPERPARENTHESISLEFT expression_numeric error:e OP_WRAPPERKEYPARENTHESISRIGHT {:
        parser.generateSyntaxError("Right parenthesis missing", ")", s);
      :}
    ;

//estructura de control while
  control_while ::=
        KW_WHILE OP_WRAPPERPARENTHESISLEFT expression OP_WRAPPERPARENTHESISRIGHT OP_WRAPPERKEYPARENTHESISLEFT control_while_body OP_WRAPPERKEYPARENTHESISRIGHT
      | error_while 
    ;

  control_while_body::=
      gramatic_body KW_BREAK    OP_INSTRUCTIONENDOPERATOR control_while_body
    | gramatic_body KW_CONTINUE OP_INSTRUCTIONENDOPERATOR control_while_body
    | gramatic_body
    ;

  error_while ::= 
      KW_WHILE:w error:e expression OP_WRAPPERPARENTHESISRIGHT OP_WRAPPERKEYPARENTHESISLEFT control_while_body OP_WRAPPERKEYPARENTHESISRIGHT {:
        parser.generateSyntaxError("Left parenthesis missing", "(", w);
      :}
    | 
      KW_WHILE:w OP_WRAPPERPARENTHESISLEFT error:e OP_WRAPPERPARENTHESISRIGHT OP_WRAPPERKEYPARENTHESISLEFT control_while_body OP_WRAPPERKEYPARENTHESISRIGHT  {:
        parser.generateSyntaxError("Expression missing in conditional structure", "expression", e);
      :}
    | 
      KW_WHILE:w OP_WRAPPERPARENTHESISLEFT expression error:e OP_WRAPPERKEYPARENTHESISLEFT control_while_body OP_WRAPPERKEYPARENTHESISRIGHT {:
        parser.generateSyntaxError("Right parenthesis missing", ")", w);
      :}
    | 
      KW_WHILE:w error:e OP_WRAPPERKEYPARENTHESISLEFT control_while_body OP_WRAPPERKEYPARENTHESISRIGHT  {:
        parser.generateSyntaxError("Some code between while and conditional expression", "While", e);
      :}
    ;

//Estructura de control for
  control_for ::= 
      KW_FOR 
      OP_WRAPPERPARENTHESISLEFT 
        control_for_instruction OP_INSTRUCTIONENDOPERATOR 
        expression OP_INSTRUCTIONENDOPERATOR
        control_for_instruction1
      OP_WRAPPERPARENTHESISRIGHT
      gramatic_body
    | error_for
    ;

  error_for ::=
      KW_FOR 
      error:e 
        control_for_instruction OP_INSTRUCTIONENDOPERATOR 
        expression OP_INSTRUCTIONENDOPERATOR
        control_for_instruction1
      OP_WRAPPERPARENTHESISRIGHT
      gramatic_body {: 
        parser.generateSyntaxError("FOR: Left parenthesis missing", "(", e); 
      :}

    |
      KW_FOR 
      OP_WRAPPERPARENTHESISLEFT 
        control_for_instruction error:e 
        expression OP_INSTRUCTIONENDOPERATOR
        control_for_instruction1
      OP_WRAPPERPARENTHESISRIGHT
      gramatic_body {: 
        parser.generateSyntaxError("FOR: Expected SEMICOLON", ";", e); 
      :}
    |
      KW_FOR 
      OP_WRAPPERPARENTHESISLEFT 
        control_for_instruction OP_INSTRUCTIONENDOPERATOR 
        error:e OP_INSTRUCTIONENDOPERATOR
        control_for_instruction1
      OP_WRAPPERPARENTHESISRIGHT
      gramatic_body {: 
        parser.generateSyntaxError("FOR: Conditional expression missing", "a<b", e); 
      :}
    | KW_FOR 
      OP_WRAPPERPARENTHESISLEFT 
        control_for_instruction OP_INSTRUCTIONENDOPERATOR 
        expression error:e
        control_for_instruction1
      OP_WRAPPERPARENTHESISRIGHT
      gramatic_body
      {: 
        parser.generateSyntaxError("FOR: Expected SEMICOLON", ";", e); 
      :}
    | KW_FOR 
      OP_WRAPPERPARENTHESISLEFT 
        control_for_instruction OP_INSTRUCTIONENDOPERATOR 
        expression OP_INSTRUCTIONENDOPERATOR
        error:e
      OP_WRAPPERPARENTHESISRIGHT
      gramatic_body
      {: 
        parser.generateSyntaxError("FOR: Incremental o decremental instruction expected", "a++", e); 
      :}
    | KW_FOR 
      OP_WRAPPERPARENTHESISLEFT 
        control_for_instruction OP_INSTRUCTIONENDOPERATOR 
        expression OP_INSTRUCTIONENDOPERATOR
        expression
      error:e
      gramatic_body
      {: 
        parser.generateSyntaxError("FOR: Right parenthesis missing", ")", e); 
      :}
    ;

  control_for_instruction ::=
      variable
    | IDENT OP_ASIG expression
    | expression
    |
    ;

  control_for_instruction1 ::=
      IDENT OP_ASIG expression
    | expression
    |
    ;

//Cuerpo gramatica 
  gramatic_body ::=
        OP_WRAPPERKEYPARENTHESISLEFT                   gramatic_body  OP_WRAPPERKEYPARENTHESISRIGHT 
      | constant                                       gramatic_body
      |             OP_INSTRUCTIONENDOPERATOR          gramatic_body
      | variable    OP_INSTRUCTIONENDOPERATOR          gramatic_body 
      | expression  OP_INSTRUCTIONENDOPERATOR          gramatic_body
      | instruction OP_INSTRUCTIONENDOPERATOR          gramatic_body
      | control_structure                              gramatic_body
      | KW_RETURN expression OP_INSTRUCTIONENDOPERATOR gramatic_body
      | KW_ELSE error:e gramatic_body
        {:
          parser.generateSyntaxError("Syntax error, illegal code after the else or if declaration", "If", e);
        :}
      | expression error:e OP_INSTRUCTIONENDOPERATOR gramatic_body  
        {:  System.out.println("\n$Error gramatic body, line 501. \n");
            parser.generateSyntaxError("Error in gramatic body, unknown error", "Gramatic Body", e);
        :}
      |
      ;

//Variables, Globales y constantes
  global ::= 
          variable:v OP_INSTRUCTIONENDOPERATOR
      //  | error_variable_definition //definida para atrapar errores
      // | variable:v error:e {:
      //     parser.generateSyntaxError("Instruction end operator was expected (;)", ";", v);
      //   :}
      ;

  constant ::=
        KW_CONST keyword_types IDENT OP_ASIG expression_atomic_literal_int OP_INSTRUCTIONENDOPERATOR
      //| error_constant
      ;

  error_constant ::=
        KW_CONST:c keyword_types IDENT error:e OP_INSTRUCTIONENDOPERATOR {:
          parser.generateSyntaxError("Constant must be defined as literal", "=", c);
        :}
      | KW_CONST:c keyword_types IDENT OP_ASIG error:e OP_INSTRUCTIONENDOPERATOR {:
          parser.generateSyntaxError("Constant must be asigned with literal", "literal", c);
        :}
      
      | KW_CONST:c keyword_types IDENT OP_ASIG LIT_HEXVALUE error:e OP_INSTRUCTIONENDOPERATOR {:
          parser.generateSyntaxError("Instruction end operator was expected (;)", ";", c);
        :}
      | KW_CONST:c keyword_types IDENT OP_ASIG LIT_DECIMALVALUE error:e OP_INSTRUCTIONENDOPERATOR {:
          parser.generateSyntaxError("Instruction end operator was expected (;)", ";", c);
        :}
      | KW_CONST:c keyword_types IDENT OP_ASIG LIT_CHARVALUE error:e OP_INSTRUCTIONENDOPERATOR {:
          parser.generateSyntaxError("Instruction end operator was expected (;)", ";", c);
        :}
      | KW_CONST:c keyword_types IDENT OP_ASIG LIT_OCTALVALUE error:e OP_INSTRUCTIONENDOPERATOR {:
          parser.generateSyntaxError("Instruction end operator was expected (;)", ";", c);
        :}
      | KW_CONST:c keyword_types IDENT OP_ASIG LIT_EXPONENTIALDEF error:e OP_INSTRUCTIONENDOPERATOR {:
          parser.generateSyntaxError("Instruction end operator was expected (;)", ";", c);
        :}
      ;

  variable ::= 
      keyword_types variable_definition 
    ;

  variable_definition ::= 
        IDENT 							
      | IDENT OP_ASIG expression:e					
      | IDENT OP_COMMA variable_definition:vd 
      | IDENT OP_ASIG expression:e OP_COMMA variable_definition:vd
      //| error_variable_definition
      ;

  error_variable_definition ::= 
    
    error:e OP_INSTRUCTIONENDOPERATOR
      {:
        parser.generateSyntaxError("Multiple variable definition require comma as separator", ",", e);
      :}
    ;

//Parametros
  parameters ::= 
        parameter OP_COMMA parameters 
      | parameter;

  parameter ::= 
        expression
      ;

  parameters_definition ::= 
        parameter_definition OP_COMMA parameters_definition 
      | parameter_definition 
      ;

  parameter_definition ::= 
        keyword_types IDENT:id
      | KW_CONST keyword_types IDENT
      | KW_CONST keyword_types IDENT OP_ASIG expression_atomic
      //| error_parameter
        ;

  error_parameter ::=
      | KW_CONST error:e OP_WRAPPERPARENTHESISRIGHT {:
        parser.generateSyntaxError("Const params must be typed", "type", e);
      :} 
      | IDENT:id error:e OP_WRAPPERPARENTHESISRIGHT {:
        parser.generateSyntaxError("Params must be typed", "type", e);
      :}
      ;

//Expresiones e instruccion
  instruction ::=
        IDENT OP_ASIG expression
      | variable
      | expression
      ;

  expression ::=    
        OP_WRAPPERPARENTHESISLEFT expression_any_type OP_WRAPPERPARENTHESISRIGHT
      | expression_any_type
      ;

  expression_any_type ::=
        expression_atomic
      | expression_unary_operator IDENT
      | IDENT expression_unary_operator
      | expression expression_binary_operators expression 
      | expression OP_TERNARYOPERATORQUESTIONMARK expression OP_TERNARYOPERATIONDOUBLEDOT expression
      | OP_NEGATION expression
      | OP_NOT expression
      ;

  expression_numeric ::=
      IDENT
    | expression_atomic_literal_int
    | expression_atomic_call_functions_anytype
    | expression_unary_operator expression_numeric  
    | expression_numeric expression_binary_operators expression_numeric 
    | expression_numeric OP_TERNARYOPERATORQUESTIONMARK expression_numeric OP_TERNARYOPERATIONDOUBLEDOT expression_numeric
    ;

  expression_atomic::=
        IDENT
      | IDENT OP_WRAPPERPARENTHESISLEFT parameters OP_WRAPPERPARENTHESISRIGHT 				
      | IDENT OP_WRAPPERPARENTHESISLEFT OP_WRAPPERPARENTHESISRIGHT 				 
      | LIT_HEXVALUE
      | LIT_DECIMALVALUE
      | LIT_FLOATVALUE
      | LIT_CHARVALUE
      | LIT_OCTALVALUE
      | LIT_STRINGDEF
      | LIT_EXPONENTIALDEF  
      ;
    
  expression_atomic_literal_nonint::=
        LIT_STRINGDEF
      | LIT_FLOATVALUE
      ;

  expression_atomic_literal_int ::=
        LIT_HEXVALUE
      | LIT_DECIMALVALUE
      | LIT_CHARVALUE
      | LIT_OCTALVALUE
      | LIT_EXPONENTIALDEF  
      ;


  expression_atomic_call_functions_anytype::=
        IDENT OP_WRAPPERPARENTHESISLEFT OP_WRAPPERPARENTHESISRIGHT 				
      | IDENT OP_WRAPPERPARENTHESISLEFT parameters OP_WRAPPERPARENTHESISRIGHT 	
      ;
    

  expression_unary_operator ::=
      //UNARY OPERATORS
        OP_MINUSMINUSASSIGN //--
      | OP_PLUSPLUSASSIGN   //++
      ;

  expression_binary_operators ::= 

      //ARITMHMETIC OPERATORS
        OP_MINUS 
      | OP_DIV 
      | OP_PLUS
      | OP_MULT
      | OP_MOD
      //RELATIONAL OPERATORS 
      | OP_LT
      | OP_LTE
      | OP_GT 
      | OP_GTE 
      | OP_EQUALCOMP
      | OP_NOTEQUALCOMP
      //LOGICAL OPERATORS
      | OP_ANDCOMP
      | OP_ORCOMP
      | OP_NEGATION
      //BITWISE OPERATORS  
      | OP_AND 
      | OP_OR 
      | OP_SHIFTOPLEFT
      | OP_SHIFTOPRIGHT
      //| OP_NOT
      | OP_XOR
      //ASSIGMENT OPERATORS
      | OP_ASIG
      | OP_PLUSASSIGN
      | OP_MINUSASSIGN
      | OP_MULTASSIGN
      | OP_DIVASSIGN
      | OP_MODASSIGN
      | OP_SHIFTLEFTASSIGN
      | OP_SHIFTRIGHTASSIGN
      | OP_NOTASSIGN
      | OP_ORASSIGN
      | OP_ANDASSIGN
      ;

//Keyword types
  keyword_types ::= 
        KW_INT 
      | KW_CHAR 
      | KW_LONG 
      | KW_SHORT 
      | KW_VOID
      | KW_FLOAT
      | KW_DOUBLE
      ;