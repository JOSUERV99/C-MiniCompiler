/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;
import lexer.CLexer;

/* define how to connect to the scanner! */
parser code {:
    // Connect this parser to a scanner!
    CLexer s;
    CParser() {}

    public void setLexer(CLexer lexer) {
        this.s = lexer;
    }

:}

init with {:  :};
scan with {: return this.s.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal EPSYLON,IDENT,KW_AUTO,KW_BREAK,KW_CASE,KW_CHAR,KW_CONST,
    KW_CONTINUE,KW_DEFAULT,KW_DO,KW_DOUBLE,KW_ELSE,
    KW_ENUM,KW_EXTERN,KW_FLOAT,KW_FOR,KW_GOTO,
    KW_IF,KW_INT,KW_LONG,KW_REGISTER,KW_RETURN,
    KW_SHORT,KW_SIGNED,KW_SIZEOF,KW_STATIC,KW_STRUCT,
    KW_SWITCH,KW_TYPEDEF,KW_UNION,KW_UNSIGNED,KW_VOID,
    KW_VOLATILE,KW_WHILE,OP_DIV,OP_PLUS,OP_MINUS,
    OP_MULT,OP_MOD,OP_COMMA,OP_GTE,OP_LTE,
    OP_LT,OP_GT,OP_NOTEQUALCOMP,OP_ORCOMP,OP_ANDCOMP,
    OP_EQUALCOMP,OP_AND,OP_XOR,OP_OR,OP_NOT,
    OP_NEGATION,OP_PLUSASSIGN,OP_MINUSASSIGN,OP_MULTASSIGN,OP_DIVASSIGN,
    OP_MINUSMINUSASSIGN,OP_PLUSPLUSASSIGN,OP_MODASSIGN,OP_ANDASSIGN,OP_NOTASSIGN,
    OP_ORASSIGN,OP_SHIFTLEFTASSIGN,OP_SHIFTRIGHTASSIGN,OP_TERNARYOPERATORQUESTIONMARK,OP_TERNARYOPERATIONDOUBLEDOT,
    OP_ASIG,OP_SHIFTOPRIGHT,OP_SHIFTOPLEFT,OP_PROPOPERATOR,OP_WRAPPERPARENTHESISLEFT,
    OP_WRAPPERPARENTHESISRIGHT,OP_WRAPPERSQUAREPARENTHESISLEFT,OP_WRAPPERSQUAREPARENTHESISRIGHT,OP_WRAPPERKEYPARENTHESISLEFT,OP_WRAPPERKEYPARENTHESISRIGHT,
    OP_INSTRUCTIONENDOPERATOR,OP_POINTEROPERATOR,OP_POINTEROPERATORASTERISC,LIT_HEXVALUE,LIT_DECIMALVALUE,LIT_FLOATVALUE,LIT_CHARVALUE,LIT_OCTALVALUE,LIT_STRINGDEF,LIT_EXPONENTIALDEF;

/* Non Terminals (generated using the terminals tokens) */
non terminal function_declaration, keyword_types, 
    parameters, parameter, program_definition, literal, expresion,
    global, variable, binary_operators, variable_definition, expresion_1;

start with program_definition;

program_definition ::= 
      function_declaration:fd program_definition:pd 
    | global:g program_definition:pd
    | EPSYLON 
    ;

function_declaration ::= 
    keyword_types IDENT OP_WRAPPERPARENTHESISLEFT parameters:p OP_WRAPPERKEYPARENTHESISRIGHT OP_INSTRUCTIONENDOPERATOR
    ;

global ::= 
    variable:v OP_INSTRUCTIONENDOPERATOR
    ;

variable ::= 
    keyword_types:kt variable_definition:vd 
    ;

variable_definition ::= 
      IDENT 								
    | IDENT OP_ASIG expresion:e					
    | IDENT OP_COMMA variable_definition:vd 
    | IDENT OP_ASIG expresion:e OP_COMMA variable_definition:vd 
    ;

expresion ::= 
      literal									
    | IDENT OP_WRAPPERKEYPARENTHESISLEFT parameters:p OP_WRAPPERKEYPARENTHESISRIGHT 				
    | IDENT 								
    | OP_AND expresion:e2 expresion_1:e1
    | OP_DIV expresion:e2 expresion_1:e1
    ;

expresion_1 ::= 
      literal expresion_1						
    | IDENT OP_WRAPPERKEYPARENTHESISLEFT parameters:p OP_WRAPPERKEYPARENTHESISRIGHT expresion_1			
    | IDENT expresion_1
    | EPSYLON
    ;

// binary_operators ::= 
//       OP_AND 
//     | OP_DIV
//     | OP_PLUS
//     | OP_EQUALCOMP
//     | OP_GT
//     | OP_LTE
//     | OP_GTE
//     | OP_LT
//     | OP_NOTEQUALCOMP
//     | OP_MINUS
//     | OP_MULT
//     | OP_OR
//     | OP_MOD
//     | OP_XOR
//     ;

literal ::= 
      LIT_CHARVALUE 
    | LIT_DECIMALVALUE 
    | LIT_EXPONENTIALDEF 
    | LIT_FLOATVALUE 
    | LIT_HEXVALUE
    | LIT_OCTALVALUE
    | LIT_STRINGDEF
    ;

parameters ::= 
      parameter OP_COMMA parameters 
    | parameter
    ;

parameter ::= 
      keyword_types IDENT:id 
    | EPSYLON
    ;

keyword_types ::= 
      KW_INT 
    | KW_CHAR 
    | KW_LONG 
    | KW_SHORT 
    | KW_VOID
    | KW_FLOAT
    ;

EPSYLON ::= 
    { /* empty definition */ }
    ;