/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;
import lexer.CLexer;
import handler.Analyzer;
import model.Token;
import errors.SyntaxError;

/* define how to connect to the scanner! */
parser code {:
    // Connect this parser to a scanner!
    CLexer s;
    Analyzer a;

    public void bind(CLexer lexer, Analyzer analyzer) {
        this.s = lexer;
        this.a = analyzer;
    }

    // public void generateSyntaxError(String message, String expected, String value) {
    //     this.a.addSyntaxError(new SyntaxError(message, null));
    // }

    public void generateSyntaxError(String message, String expected, Object o) {

        if (o != null)
        {
          Token findedToken = (Token) o;
          this.a.addSyntaxError(new SyntaxError(message, findedToken));
        }
        else
        {
          this.a.addSyntaxError(new SyntaxError(message, null));
        }
    }

    public void syntax_error(Symbol cur_token) {
	    System.err.println("Syntax error at line: " + (cur_token.right+1) + " at column: " + (cur_token.left+1) + " on: " + cur_token.value);
    }

    public void unrecovered_syntax_error(Symbol cur_token){
    	System.err.println("Fatal error at line: " + (cur_token.right+1) + " at column: " + (cur_token.left+1) + " on: " + cur_token.value);
    }
:}

init with {:  :};
scan with {: return this.s.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal IDENT;
terminal KW_AUTO,KW_BREAK,KW_CASE,KW_CHAR,KW_CONST;
terminal KW_CONTINUE,KW_DEFAULT,KW_DO,KW_DOUBLE,KW_ELSE;
terminal KW_ENUM,KW_EXTERN,KW_FLOAT,KW_FOR,KW_GOTO;
terminal KW_IF,KW_INT,KW_LONG,KW_REGISTER,KW_RETURN;
terminal KW_SHORT,KW_SIGNED,KW_SIZEOF,KW_STATIC,KW_STRUCT;
terminal KW_SWITCH,KW_TYPEDEF,KW_UNION,KW_UNSIGNED,KW_VOID;
terminal KW_VOLATILE,KW_WHILE,OP_DIV,OP_PLUS,OP_MINUS;
terminal OP_MULT,OP_MOD,OP_COMMA,OP_GTE,OP_LTE;
terminal OP_LT,OP_GT,OP_NOTEQUALCOMP,OP_ORCOMP,OP_ANDCOMP;
terminal OP_EQUALCOMP,OP_AND,OP_XOR,OP_OR,OP_NOT;
terminal OP_NEGATION,OP_PLUSASSIGN,OP_MINUSASSIGN,OP_MULTASSIGN,OP_DIVASSIGN;
terminal OP_MINUSMINUSASSIGN,OP_PLUSPLUSASSIGN,OP_MODASSIGN,OP_ANDASSIGN,OP_NOTASSIGN;
terminal OP_ORASSIGN,OP_SHIFTLEFTASSIGN,OP_SHIFTRIGHTASSIGN,OP_TERNARYOPERATORQUESTIONMARK,OP_TERNARYOPERATIONDOUBLEDOT;
terminal OP_ASIG,OP_SHIFTOPRIGHT,OP_SHIFTOPLEFT,OP_PROPOPERATOR;
terminal OP_WRAPPERPARENTHESISLEFT,OP_WRAPPERPARENTHESISRIGHT,OP_WRAPPERSQUAREPARENTHESISLEFT,OP_WRAPPERSQUAREPARENTHESISRIGHT,OP_WRAPPERKEYPARENTHESISLEFT,OP_WRAPPERKEYPARENTHESISRIGHT;
terminal OP_INSTRUCTIONENDOPERATOR,OP_POINTEROPERATOR,OP_POINTEROPERATORASTERISC,LIT_HEXVALUE,LIT_DECIMALVALUE,LIT_FLOATVALUE,LIT_CHARVALUE,LIT_OCTALVALUE,LIT_STRINGDEF,LIT_EXPONENTIALDEF;
/* Non Terminals (generated using the terminals tokens) */


//Non-terminals function
non terminal  function_declaration_0,
              function_declaration_1,
              function_declaration,
              keyword_types,
              parameters,
              parameter,
              parameters_definition,
              parameter_definition,
              program_definition
              ;

non terminal  gramatic_body;
//Non-terminal expressions
non terminal  instruction,
              expression,
              expression_any_type,
              expression_numeric,
              expression_atomic_0,
              expression_atomic,
              expression_unary_operator,
              expression_binary_operators
              ;

non terminal expression_atomic_literal_int,
             expression_atomic_literal_nonint
             ;

non terminal expression_atomic_call_functions_anytype;
//Non-terminal Variables
non terminal global, constant, variable, variable_definition;
//Non-terminal Estrucutura Control
non terminal control_structure, control_if, control_if_else, control_else; 

//Non-terminal switch
non terminal control_switch, control_switch_case;

//Non-terminal ciclo while
non terminal control_while, control_while_body;

//Non terminal ciclo for
non terminal control_for, control_for_instruction, control_for_instruction1, control_for_body;

//Program Start non termi
non terminal start_program;

//Error non terminal productions
non terminal error_if, error_while;

//precedence gramatic body
precedence left     IDENT;
precedence left     OP_WRAPPERKEYPARENTHESISLEFT, OP_WRAPPERKEYPARENTHESISRIGHT;
precedence left     OP_WRAPPERPARENTHESISLEFT, OP_WRAPPERPARENTHESISRIGHT;
precedence nonassoc     LIT_DECIMALVALUE, LIT_FLOATVALUE, LIT_HEXVALUE, LIT_OCTALVALUE, LIT_EXPONENTIALDEF, LIT_CHARVALUE, LIT_STRINGDEF;     
precedence right  OP_INSTRUCTIONENDOPERATOR;
//predence If-ELSE
precedence left KW_ELSE, KW_RETURN;
precedence right KW_IF;
precedence nonassoc KW_CONST;

//precedence Switch
precedence left KW_CASE,KW_SWITCH;
precedence right KW_BREAK;

//precedence While
precedence left KW_WHILE, KW_FOR;

//precedende variables
precedence nonassoc KW_INT 
                  , KW_CHAR 
                  , KW_LONG 
                  , KW_SHORT 
                  , KW_VOID
                  , KW_FLOAT
                  , KW_DOUBLE
                  ;
//precedence operators expression
precedence left     OP_PLUS, OP_MINUS;
precedence left     OP_MULT, OP_DIV, OP_MOD;
precedence left     OP_TERNARYOPERATORQUESTIONMARK, OP_TERNARYOPERATIONDOUBLEDOT;

precedence nonassoc 
    //RELATIONAL OPERATORS 
      OP_LT
    , OP_LTE
    , OP_GT 
    , OP_GTE 
    , OP_EQUALCOMP
    , OP_NOTEQUALCOMP
    //LOGICAL OPERATORS
    , OP_ANDCOMP
    , OP_ORCOMP
    , OP_NEGATION
    //BITWISE OPERATORS  
    , OP_AND 
    , OP_OR 
    , OP_SHIFTOPLEFT
    , OP_SHIFTOPRIGHT
    , OP_NOT
    , OP_XOR
    //ASSIGMENT OPERATORS
    , OP_ASIG
    , OP_PLUSASSIGN
    , OP_MINUSASSIGN
    , OP_MULTASSIGN
    , OP_DIVASSIGN
    , OP_MODASSIGN
    , OP_SHIFTLEFTASSIGN
    , OP_SHIFTRIGHTASSIGN
    , OP_NOTASSIGN
    , OP_ORASSIGN
    , OP_ANDASSIGN
      //UNARY OPERATORS
      //--
    , OP_MINUSMINUSASSIGN 
      //++
    , OP_PLUSPLUSASSIGN
    ;

start with start_program;

//https://stackoverflow.com/questions/44091680/java-cup-runtime-symbol-eof-has-not-been-declared
//https://www.cs.auckland.ac.nz/courses/compsci330s1c/lectures/330ChaptersPDF/Chapt4.pdf
start_program ::= 
    program_definition
    ;

program_definition ::= 
      function_declaration:fd program_definition:pd 
    | global:g program_definition:pd      
    |
    ;
/*
Funciones -> Tipo Identifier ( Parametros ) { CuerpoGramatica} |
			 Tipo Identifier ( Parametros )
*/
function_declaration ::= 
      keyword_types:kt IDENT OP_WRAPPERPARENTHESISLEFT  function_declaration_0 function_declaration_1
    ;
function_declaration_0 ::=
      parameters_definition OP_WRAPPERPARENTHESISRIGHT 
    | OP_WRAPPERPARENTHESISRIGHT 
    ;
function_declaration_1 ::=
    gramatic_body
    ;

/*
EstructuraControl	->  Control-If | Control-Switch | Control-While | Control-For
*/
control_structure::=
      control_if
    | control_switch
    | control_while
    | control_for
;


control_if ::=
      control_if_else
    | error_if
    ;


control_if_else::=  
      KW_IF OP_WRAPPERPARENTHESISLEFT expression OP_WRAPPERPARENTHESISRIGHT gramatic_body control_else
    ;


control_else::=
      KW_ELSE gramatic_body
    | KW_ELSE instruction
    | instruction
    | gramatic_body
    ;

error_if ::=
    KW_IF:i error:e {: 
      parser.generateSyntaxError("Left parenthesis missing", "(", i);
    :} OP_WRAPPERKEYPARENTHESISRIGHT
  | 
    KW_IF:i OP_WRAPPERPARENTHESISLEFT error:e {: 
      parser.generateSyntaxError("Expression missing in conditional structure", "expression", null);
    :} OP_WRAPPERKEYPARENTHESISRIGHT
  |
    KW_IF:i OP_WRAPPERPARENTHESISLEFT expression error:e {:    
      parser.generateSyntaxError("Right parenthesis missing", ")", i);
    :} OP_WRAPPERKEYPARENTHESISRIGHT
 // | KW_IF OP_WRAPPERPARENTHESISLEFT OP_WRAPPERPARENTHESISRIGHT error {: System.out.println("Expression missing"); :} OP_WRAPPERKEYPARENTHESISRIGHT
  ;

control_switch::=
    KW_SWITCH OP_WRAPPERPARENTHESISLEFT expression_numeric OP_WRAPPERPARENTHESISRIGHT control_switch_case
    ;


control_switch_case::=
    OP_WRAPPERKEYPARENTHESISLEFT control_switch_case OP_WRAPPERKEYPARENTHESISRIGHT  control_switch_case
  | KW_CASE     expression_numeric  OP_TERNARYOPERATIONDOUBLEDOT                    control_switch_case
  | KW_DEFAULT  expression_numeric  OP_TERNARYOPERATIONDOUBLEDOT                    control_switch_case
  | KW_BREAK OP_INSTRUCTIONENDOPERATOR                                              control_switch_case
  | gramatic_body                                                              
  ;


control_while ::=
      KW_WHILE OP_WRAPPERPARENTHESISLEFT expression OP_WRAPPERPARENTHESISRIGHT control_while_body 
    | error_while
  ;

control_while_body::=
    KW_BREAK OP_INSTRUCTIONENDOPERATOR control_while_body
  | gramatic_body
  ;

error_while ::= 
    KW_WHILE:w error:e {:
      parser.generateSyntaxError("Left parenthesis missing", "(", w);
    :} OP_WRAPPERKEYPARENTHESISRIGHT
  | 
    KW_WHILE:w OP_WRAPPERPARENTHESISLEFT error:e {:
      parser.generateSyntaxError("Expression missing in conditional structure", "expression", null);
    :} OP_WRAPPERKEYPARENTHESISRIGHT
  | 
    KW_WHILE:w OP_WRAPPERPARENTHESISLEFT expression error:e {:
      parser.generateSyntaxError("Right parenthesis missing", ")", w);
    :} OP_WRAPPERKEYPARENTHESISRIGHT
  ;

control_for ::= 
    KW_FOR 
    OP_WRAPPERPARENTHESISLEFT 
      control_for_instruction OP_INSTRUCTIONENDOPERATOR 
      expression OP_INSTRUCTIONENDOPERATOR
      control_for_instruction1
    OP_WRAPPERPARENTHESISRIGHT
     gramatic_body
  ;

control_for_instruction ::=
    variable
  | IDENT OP_ASIG expression
  | expression
  |
  ;

control_for_instruction1 ::=
    IDENT OP_ASIG expression
  | expression
  |
  ;

gramatic_body ::=
      OP_WRAPPERKEYPARENTHESISLEFT                   gramatic_body  OP_WRAPPERKEYPARENTHESISRIGHT 
    | constant                                       gramatic_body
    |             OP_INSTRUCTIONENDOPERATOR          gramatic_body
    | variable    OP_INSTRUCTIONENDOPERATOR          gramatic_body 
    | expression  OP_INSTRUCTIONENDOPERATOR          gramatic_body
    | instruction OP_INSTRUCTIONENDOPERATOR          gramatic_body
    | control_structure                              gramatic_body
    | KW_RETURN expression OP_INSTRUCTIONENDOPERATOR gramatic_body
    |
    ;


global ::= 
    variable:v OP_INSTRUCTIONENDOPERATOR
    ;


constant ::=
    KW_CONST keyword_types IDENT OP_ASIG expression_atomic_0 OP_INSTRUCTIONENDOPERATOR
    ;


variable ::= 
    keyword_types:kt variable_definition:vd 
    ;

variable_definition ::= 
      IDENT 								
    | IDENT OP_ASIG expression:e					
    | IDENT OP_COMMA variable_definition:vd 
    | IDENT OP_ASIG expression:e OP_COMMA variable_definition:vd 
    ;


parameters ::= 
      parameter OP_COMMA parameters 
    | parameter;

parameter ::= 
      expression
    ;

parameters_definition ::= 
      parameter_definition OP_COMMA parameters_definition 
    | parameter_definition;

parameter_definition ::= 
      keyword_types IDENT:id
    | KW_CONST keyword_types IDENT
    | KW_CONST keyword_types IDENT OP_ASIG expression_atomic_0
      ;


instruction ::=
      IDENT OP_ASIG expression
    | variable
    | expression
    ;

expression ::=    
      OP_WRAPPERPARENTHESISLEFT expression_any_type OP_WRAPPERPARENTHESISRIGHT
    | expression_any_type
    ;

expression_any_type ::=
      expression_atomic
    | expression_unary_operator IDENT
    | IDENT expression_unary_operator
    | expression expression_binary_operators expression 
    | expression OP_TERNARYOPERATORQUESTIONMARK expression OP_TERNARYOPERATIONDOUBLEDOT expression
    ;

expression_numeric ::=
    IDENT
  | expression_atomic_literal_int
  | expression_atomic_call_functions_anytype
  | expression_unary_operator expression_numeric  
  | expression_numeric expression_binary_operators expression_numeric 
  | expression_numeric OP_TERNARYOPERATORQUESTIONMARK expression_numeric OP_TERNARYOPERATIONDOUBLEDOT expression_numeric
  ;

expression_atomic::=
      IDENT
    | IDENT OP_WRAPPERPARENTHESISLEFT parameters OP_WRAPPERPARENTHESISRIGHT 				
    | IDENT OP_WRAPPERPARENTHESISLEFT OP_WRAPPERPARENTHESISRIGHT 				 
    | LIT_HEXVALUE
    | LIT_DECIMALVALUE
    | LIT_FLOATVALUE
    | LIT_CHARVALUE
    | LIT_OCTALVALUE
    | LIT_STRINGDEF
    | LIT_EXPONENTIALDEF  
    ;
  
expression_atomic_literal_nonint::=
      LIT_STRINGDEF
    | LIT_FLOATVALUE
    ;

expression_atomic_literal_int ::=
      			 
      LIT_HEXVALUE
    | LIT_DECIMALVALUE
    | LIT_CHARVALUE
    | LIT_OCTALVALUE
    | LIT_EXPONENTIALDEF  
    ;


expression_atomic_call_functions_anytype::=

      IDENT OP_WRAPPERPARENTHESISLEFT OP_WRAPPERPARENTHESISRIGHT 				
    | IDENT OP_WRAPPERPARENTHESISLEFT parameters OP_WRAPPERPARENTHESISRIGHT 	
    ;
  

expression_unary_operator ::=
    //UNARY OPERATORS
      OP_MINUSMINUSASSIGN //--
    | OP_PLUSPLUSASSIGN   //++
    ;

expression_binary_operators ::= 

    //ARITMHMETIC OPERATORS
      OP_MINUS 
    | OP_DIV 
    | OP_PLUS
    | OP_MULT
    | OP_MOD
    //RELATIONAL OPERATORS 
    | OP_LT
    | OP_LTE
    | OP_GT 
    | OP_GTE 
    | OP_EQUALCOMP
    | OP_NOTEQUALCOMP
    //LOGICAL OPERATORS
    | OP_ANDCOMP
    | OP_ORCOMP
    | OP_NEGATION
    //BITWISE OPERATORS  
    | OP_AND 
    | OP_OR 
    | OP_SHIFTOPLEFT
    | OP_SHIFTOPRIGHT
    | OP_NOT
    | OP_XOR
    //ASSIGMENT OPERATORS
    | OP_ASIG
    | OP_PLUSASSIGN
    | OP_MINUSASSIGN
    | OP_MULTASSIGN
    | OP_DIVASSIGN
    | OP_MODASSIGN
    | OP_SHIFTLEFTASSIGN
    | OP_SHIFTRIGHTASSIGN
    | OP_NOTASSIGN
    | OP_ORASSIGN
    | OP_ANDASSIGN
    ;

keyword_types ::= 
      KW_INT 
    | KW_CHAR 
    | KW_LONG 
    | KW_SHORT 
    | KW_VOID
    | KW_FLOAT
    | KW_DOUBLE
    ;